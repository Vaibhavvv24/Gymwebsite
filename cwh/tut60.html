<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arrow Functions</title>
</head>
<body>
    <script>
        //arrow fn
        // greet=()=>{
        //     console.log("vaibhav is the best")
        // }
        // greet()
        // //arrow fn is a shortcut
        // setTimeout(() => {
        //     console.log('Vaibhav is horny')
        // }, 3000);
        // // sum=(a,b)=>a+b   //another shortcut to write a function
        // // console.log(sum(10,20))
        // //dont even have to put brackets u can just write param like that also
        // half=a=>a/2   //only if we have one parameter(even if u dont have params then we still need to put brackets)
        // console.log(half(10))

        // //oops in JS
        // // Object literal is simply a key:value pair data structure. 

// Storing variables and functions together in one container, 
        // obj={
        //     greeting:"we are happy",
        //     names:['Vaibhav','chaman','Rogan','Horny'],
        //     speak(){
        //         this.names.forEach((student) => {
        //             console.log(this.greeting+"Heloo"+student)  //'this' is of the object hence not undefined as it is an arrow fn(if normal fn would have been used then it would have been undefined as it cant acces the outer object)
        //         });
        //     }

        // }
        // obj.speak()

        // ðŸ‘‰ What if we want object as a value inside an Object 


// let bioData = { 
//   myName : {
//     realName : "vinod",
//     channelName : "thapa technical" 
//   },
//   myAge : 26,
//   getData (){
//     console.log(`My name is ${bioData.myName} and my age is ${bioData.myAge}`);
//   }
// }

// console.log(bioData.myName.channelName );

// 2ï¸âƒ£ What is this Object?

// The definition  of "this" object is that it contain the current context. 

// The this object can have different values depending on where it is placed.  

// // For Example 1 
// console.log(this.alert('Awesome'));
// // it refers to the current context and that is window global object 


// // ex 2 
// function myName() {
//     console.log(this);
// }
// myName();
//current obj is window


// // ex 3 

// var myNames = 'vinod';
// function myName() {
//     console.log(this.myNames);
// }
// myName();   //gives op vinod


// // ex 4 
// const obj = {
//     myAge : 26,
//     myName() {
//       console.log(this.myAge);
//     }
// }
// obj.myName();   //refers to obj in this case(this is similar to self)

// // ex 5 
// // this object will not work with arrow function bcz arrow function is bound to class.

// const obj = {
//     myAge : 26,
//     myName : () => {
//       console.log(this);
//     }
// }
// obj.myName();


// // ex 6

// let bioData = {
//     myName : {
//         realName : "vinod thapa",
//         channelName : 'thapa technical'
//     },
//     // things to remember is that the myName is the key and the object is act like a value 
//     myAge : 26,
//     getData (){
//       console.log(`My name is ${this.myName.channelName} and my age is ${this.myAge} `);
//     }
//op will be thapa technical and age will be 26 since this refers to biodata
//   }

//   bioData.getData();


// // call method is used to call the method of another object 
// // or with call(), an object can use a method belonging to another object 

// // But as per other it is simply the way to use the this keyword or another object 


//// 4ï¸âƒ£ Destructuring in ES6
// The destructuring assignment syntax is a JavaScript expression 
// that makes it possible to unpack values from arrays, 
// or properties from objects, into distinct variables.

  //  âž¡ Array Destructuring  ðŸ

  // const myBioData = ['vinod', 'thapa', 26];

  // let myFName = myBioData[0];
  // let myLName = myBioData[1];
  // let myAge = myBioData[2];
  //better way to destructure an array
  //these two are equivalent
  
// let [myFName,myAge, myLName] = myBioData;
// console.log(myAge);

  // we can add values too 
  
  // let [myFName,myLName,myAge, myDegree="MCS"] = myBioData;
  // console.log(myDegree);

  // âž¡ Object destructuring ðŸ
  // const myBioData = {
  //   myFname : 'vinod',
  //   myLname : 'thapa',
  //   myAge : 26
  // }

  // let age = myBioData.age;
  // let myFname = myBioData.myFname;
  //better way is neeche
  //we can add values also

  // let {myFname,myLname,myAge, myDegree="MCS"} = myBioData;
  // console.log(myLname);


// 5ï¸âƒ£ Object Properties 

// âž¡ we can now use Dynamic Properties 

      // let myName = "vinod";
      // const myBio = {
      //   [myName] : "hello how are you?",   //whatever is written in square brackets will be replaced with whtaever its assigned earlier
      //   [20 + 6] : "is my age"    //myname will be replaced with vinod
      // }

      // console.log(myBio);

  // âž¡ no need to write key and value, if both are same 

  // let myName = "vinod thapa";
  // let myAge = 26;

  // const myBio = {myName,myAge}
  //eqivalent to 
//   //const myBio={
//     myName:myName,
//     myAge:myAge
//   }

  // console.log(myBio);

  
  
  
  // 7ï¸âƒ£Spread Operator

// const colors = ['red', 'green', 'blue', 'white', 'pink'];

// const myColors = ['red', 'green', 'blue', 'white','pink', 'yellow', 'black'];
//if person edits colors arrray it will automatically reflect in myfav colors array

// const MyFavColors = [ ...colors, 'yellow', 'black'];     //...Array name add kardo so that u dont have to repeat those clors

// console.log(MyFavColors);


// ES7 features 

// 1: array include 
// const colors = ['red', 'green', 'blue', 'white', 'pink'];
// const isPresent = colors.includes('purple');   //to check if array has some ele or not
// console.log(isPresent);

  
// ES8 Features 

// String padding
// Object.values()
// Object.entries()

// const message = "vinod";
// // console.log(message);
// // console.log(message.padStart(8));    //if length of  string is x and parameter of padstart is x+y then total whitespaces in the string from starting are y
// //similarly for pad end from the ending there will be y spaces
// console.log(message.padEnd(10));


// const person = { name: 'Fred', age: 87 };

// // // // console.log( Object.values(person) );   //to loop on an object(gives values in an array)
// //console.log(Object.entries(person))  //will give a 2d array in which each array will correspond to a key-val pair
// const arrObj =  Object.entries(person);
// console.log(Object.fromEntries(arrObj));   //it transforms an array of key value pairs into an object

  //// ES2018

// const person = { name: 'Fred', age: 87, degree : "mcs" };   //same spread property can be used on objects as well
// const sPerson = { ...person };

// console.log(person);
// console.log(sPerson);


//advanced js
 // 2ï¸âƒ£: Higher Order Function
// // function which takes another function as an arguments is called HOF 
// // wo function jo dusre function ko as an argument accept krta hai use HOF 

// // 3ï¸âƒ£: Callback Function
// // function which get passed as an argument to another function is called CBF 
// // A callback function is a function that is passed as an argument to 
// // another function, to be â€œcalled backâ€ at a later time. 

// // Jis bhi function ko hum kisi or function ke under as an arguments passed 
// // krte hai then usko hum CallBack fun bolte hai 


// // // we need to create a calculator 

// const add = (a,b) => {
//     return a+b;
// }
// // console.log(add(5,2));

// const subs = (a,b) => {
//     return Math.abs(a-b);
// }
// const mult = (a,b) => {
//     return a*b;
// }

// const calculator = (num1,num2, operator) => {
//   return operator(num1,num2);
// }

// calculator(5,2,subs)

// console.log(calculator(5,2,subs));

// // // I have to do the hardcoded for each operation which is bad
// // // we will use the callback and the HOF to make it simple to use 




// // // Now instead of calling each function indivisually we can call it
// // // by simply using one function that is calculator 

// console.log(calculator(5,6,add));
// console.log(calculator(5,6,subs));
// console.log(calculator(5,6,mult));

// // In the above example, calculator is the higher-order function, 
// // which accepts three arguments, the third one being the callback.
// // Here the calculator is called the Higher Order Function because it takes
// // another function as an argument 

// // and add, sub and mult are called the callback function bcz they are passed 
// // as an argument to another fucntion 

// // InterView Question 
// // Difference Between Higher Order Function and Callback Function ?


// // 5ï¸âƒ£ Hoisting in JavaScript 

// // we have a creation phase and execution phase.

// // Hoisting in Javascript is a mechanism where variables and functions
// // declarations are moved to the top of their scope before the code execute.

// For Example ðŸ‘‡
// console.log(myName);
// let myName;
// myName = "thapa";

// // How it will be in output during creation phase 

// 1: var myName = undefined;
// 2: console.log(myName);
// 3: myName = "thapa";   //cant be used with let


// //ðŸ˜² In ES2015 (a.k.a. ES6), hoisting is avoided by using the let keyword 
// // instead of var. (The other difference is that variables declared 
// // with let are local to the surrounding block, not the entire function.)



// 6ï¸âƒ£ What is Scope Chain and Lexical Scoping in JavaScript? 

// // The scope chain is used to resolve the value of variable names in JS.

// // scope chain in js is lexically defined, which means that we can 
// // see what the scope chain will be by looking at the code. 

// // At the top, we have the Global Scope, which is the window Object
// // in the browser.

// // Lexical Scoping means Now, the inner function can get access to 
// // their parent functions variables But the vice-versa is not true.


// // For Example ðŸ‘‡

// let a = "Hello guys. "; // global scope
// const first= () => {
//   let b = " How are you?"
 
//     const second = () => {
//       let c = " Hii, I am fine thank youðŸ™";
//       console.log(a+b+c);
//     }
//     second();
//     console.log(a+b+c); //I can't use C since it is in inner function of first fn
// }

// first();  //cnt access b and c



// // 7ï¸âƒ£ What is Closures in JavaScript ðŸ¤”

// // A closure is the combination of a function bundled together (enclosed) with references 
// // to its surrounding state (the lexical environment). 

// // In other words, a closure gives you 
// // access to an outer functionâ€™s scope from an inner function. 

// // In JavaScript, closures are created every time a function is created, at function creation time.

// // For Example ðŸ‘‡

// const outerFun = (a) => {
//     let b = 10;
//     const innerFun = () => {
//       let sum = a+b;
//       console.log(`the sum of the two no is ${sum}`);
//     }
//     innerFun();
// }
// outerFun(5);

// // it same like lexical scoping the above one

// // One more Example ðŸ‘‡

// const outerFun = (a) => {
//   let b = 10;
//   const innerFun = () => {
//     let sum = a+b;
//     console.log(`the sum of the two no is ${sum}`);
//   }
//   return innerFun;
// }
// let checkClousure = outerFun(5);
// console.dir(checkClousure);   //tells details about the op


//diff between synchronus and asynchronus js
// // 6ï¸âƒ£:   Synchronous JavaScript Prog 

// 1work = 10min
// 2work = 5s

// const fun2 = () => {
//   console.log(`Function 2ï¸âƒ£ is called`);
// }

// const fun1 = () => {
//   console.log(`Function 1 is called`);
//   fun2();
//   console.log(`Function 1 is called Again âœŒ`);
// }

// fun1(); //order will be fun1 called fun2 called fun1 called again 


// Asynchronous JavaScript Prog 

// const fun2 = () => {
//   setTimeout(()=> {
//       console.log(`Function 2ï¸âƒ£  is called`);
//   }, 2000);
// }

// const fun1 = () => {
//   console.log(`Function 1 is called`);
//   fun2();
//   console.log(`Function 1 is called Again âœŒ`);
// }

// fun1();
//order will be fun1 called fun1 called again fun2 called






    </script>
</body>
</html>